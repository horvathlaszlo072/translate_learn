0
00:00:01,340 --> 00:00:02,879
[Autogenerated] the de structuring Centex

1
00:00:02,879 --> 00:00:04,620
is really simple, but I've seen it

2
00:00:04,620 --> 00:00:06,790
confused many people before. Let me make

3
00:00:06,790 --> 00:00:09,230
sure that does not happen to you. The

4
00:00:09,230 --> 00:00:11,339
structuring works for both arrays and

5
00:00:11,339 --> 00:00:13,960
objects. Here's an example for objects

6
00:00:13,960 --> 00:00:16,429
using the built in math object in

7
00:00:16,429 --> 00:00:18,519
JavaScript when you have an object like

8
00:00:18,519 --> 00:00:21,379
math and you want to extract values out of

9
00:00:21,379 --> 00:00:23,670
this object into the enclosing scope, for

10
00:00:23,670 --> 00:00:25,859
example, instead of using math up, I would

11
00:00:25,859 --> 00:00:28,140
like to just have a constant named pi toe.

12
00:00:28,140 --> 00:00:30,559
Hold the value of math up I, which is easy

13
00:00:30,559 --> 00:00:31,980
because you can have a line like this.

14
00:00:31,980 --> 00:00:34,189
Format that pie in another one for E. If

15
00:00:34,189 --> 00:00:37,039
you need the same for E and so on with the

16
00:00:37,039 --> 00:00:39,890
de structuring Centex, these three lines

17
00:00:39,890 --> 00:00:43,500
are equivalent to this single line IT

18
00:00:43,500 --> 00:00:45,740
these structures the three properties out

19
00:00:45,740 --> 00:00:48,329
of its right hand object and into the

20
00:00:48,329 --> 00:00:50,829
current scope. This is useful when you

21
00:00:50,829 --> 00:00:52,670
need to use a few properties out of a

22
00:00:52,670 --> 00:00:56,229
bigger object. For example, here is a line

23
00:00:56,229 --> 00:00:58,439
to the structure, just the read file

24
00:00:58,439 --> 00:01:02,109
method out of the nodes FS module. After

25
00:01:02,109 --> 00:01:05,329
this line, I can use the read file method

26
00:01:05,329 --> 00:01:08,640
directly like this. These structuring also

27
00:01:08,640 --> 00:01:11,620
works inside function arguments. If the

28
00:01:11,620 --> 00:01:13,750
argument passed to a function is an

29
00:01:13,750 --> 00:01:16,209
object, instead of using the name of the

30
00:01:16,209 --> 00:01:18,200
object every time you want to access its

31
00:01:18,200 --> 00:01:20,129
properties, you can use the these

32
00:01:20,129 --> 00:01:22,239
structuring Centex within the function

33
00:01:22,239 --> 00:01:24,319
parentheses to these structure, just the

34
00:01:24,319 --> 00:01:26,379
properties that you are interested in and

35
00:01:26,379 --> 00:01:28,709
make them local to that function. This

36
00:01:28,709 --> 00:01:30,930
generally improves the readability of

37
00:01:30,930 --> 00:01:33,840
functions. So here we have a Circle Area

38
00:01:33,840 --> 00:01:36,319
function, which expects an object as its

39
00:01:36,319 --> 00:01:38,890
argument, and it expects that object to

40
00:01:38,890 --> 00:01:41,000
have a radius property on. We're de

41
00:01:41,000 --> 00:01:42,769
structuring the radius property out of

42
00:01:42,769 --> 00:01:45,390
that object and using it locally in the

43
00:01:45,390 --> 00:01:48,340
function. If we call this Circle area

44
00:01:48,340 --> 00:01:50,500
function with an object like circle, it

45
00:01:50,500 --> 00:01:53,879
will use its radius property inside for

46
00:01:53,879 --> 00:01:56,930
its calculation. Let's go ahead and test

47
00:01:56,930 --> 00:01:59,629
that you'll see the Circle Area

48
00:01:59,629 --> 00:02:03,859
calculation working as expected. These

49
00:02:03,859 --> 00:02:06,260
structured arguments can also be defined

50
00:02:06,260 --> 00:02:08,560
with defaults like regular arguments. If,

51
00:02:08,560 --> 00:02:10,870
say, I'd like to use the default value of

52
00:02:10,870 --> 00:02:14,389
two for precision property here. Let's

53
00:02:14,389 --> 00:02:17,689
define second IOPS shins argument for this

54
00:02:17,689 --> 00:02:20,539
circle area function and the structure

55
00:02:20,539 --> 00:02:23,189
precision out of that argument to use it

56
00:02:23,189 --> 00:02:25,930
in the functions body. If I'd like to use

57
00:02:25,930 --> 00:02:27,919
the default value of two for the precision

58
00:02:27,919 --> 00:02:30,240
property, I can just use the equal sign

59
00:02:30,240 --> 00:02:32,349
here after the structuring precision. And

60
00:02:32,349 --> 00:02:34,689
that means default for precision, if not

61
00:02:34,689 --> 00:02:37,729
specified, will be, too. I can also make

62
00:02:37,729 --> 00:02:40,439
this whole second argument optional using

63
00:02:40,439 --> 00:02:42,800
an equal sign after the de structuring

64
00:02:42,800 --> 00:02:45,879
Centex. The same call here will use an

65
00:02:45,879 --> 00:02:48,379
empty object for the second argument of

66
00:02:48,379 --> 00:02:49,909
the function, and then it will use the

67
00:02:49,909 --> 00:02:51,819
default value of two for the precision

68
00:02:51,819 --> 00:02:55,340
property that is now used in the function.

69
00:02:55,340 --> 00:02:57,560
Of course, if you called the circle area

70
00:02:57,560 --> 00:03:00,030
function with the second argument that has

71
00:03:00,030 --> 00:03:02,379
a precision property, that value will be

72
00:03:02,379 --> 00:03:05,169
used inside the function. As you can see,

73
00:03:05,169 --> 00:03:07,800
this de structuring feature offers a good

74
00:03:07,800 --> 00:03:10,169
alternative to using named arguments in

75
00:03:10,169 --> 00:03:12,240
functions, which is a much better thing

76
00:03:12,240 --> 00:03:15,270
that relying on positional arguments de

77
00:03:15,270 --> 00:03:17,389
structuring, whether you do it in function

78
00:03:17,389 --> 00:03:20,439
arguments or directly with variables, also

79
00:03:20,439 --> 00:03:23,449
works for a raise. If you have an array of

80
00:03:23,449 --> 00:03:25,849
values and you want to extract these

81
00:03:25,849 --> 00:03:28,430
values into local variables, you can use

82
00:03:28,430 --> 00:03:30,680
the items positions to the structure,

83
00:03:30,680 --> 00:03:32,550
their values into local variables just

84
00:03:32,550 --> 00:03:34,930
like this. Not how I used double-click.

85
00:03:34,930 --> 00:03:36,689
Mama's here to skip the structuring. The

86
00:03:36,689 --> 00:03:38,979
third item injury, the D structured

87
00:03:38,979 --> 00:03:41,509
variable fourth here will hold the value

88
00:03:41,509 --> 00:03:45,860
of 40. This is useful when combined with

89
00:03:45,860 --> 00:03:48,139
the rest operator, which has an example

90
00:03:48,139 --> 00:03:51,050
here. By using these three dots, we are

91
00:03:51,050 --> 00:03:53,280
asking JavaScript to the structure on Lee

92
00:03:53,280 --> 00:03:55,879
one item out of this array and then create

93
00:03:55,879 --> 00:03:58,780
a new array under the name Rest of items

94
00:03:58,780 --> 00:04:00,849
toe. Hold the rest of the items after

95
00:04:00,849 --> 00:04:04,610
removing the first-one. Let's test that so

96
00:04:04,610 --> 00:04:08,610
first here will be 10 and rest of items

97
00:04:08,610 --> 00:04:12,620
will be an array of 2030 and 40. This is

98
00:04:12,620 --> 00:04:15,120
powerful for splitting the array, and it's

99
00:04:15,120 --> 00:04:17,360
also even more powerful when working with

100
00:04:17,360 --> 00:04:19,910
objects to filter out certain properties

101
00:04:19,910 --> 00:04:22,480
from an object. Here's an example of that.

102
00:04:22,480 --> 00:04:24,850
Say that we have this data object, which

103
00:04:24,850 --> 00:04:27,269
has a few temp properties, and we'd like

104
00:04:27,269 --> 00:04:29,379
to create a new object that has the same

105
00:04:29,379 --> 00:04:33,240
data except for temp one and tempt to-be

106
00:04:33,240 --> 00:04:36,829
we-can D structure temp one attempt to and

107
00:04:36,829 --> 00:04:38,850
then use the rest operator to get the

108
00:04:38,850 --> 00:04:40,970
remaining properties into a new object

109
00:04:40,970 --> 00:04:44,730
called person. Just like the three dots of

110
00:04:44,730 --> 00:04:47,920
rest. You can use the three dots to spread

111
00:04:47,920 --> 00:04:50,300
one array or object into a new array or

112
00:04:50,300 --> 00:04:52,930
object. This is useful for copying arrays

113
00:04:52,930 --> 00:04:56,259
and objects. You can spread the items in

114
00:04:56,259 --> 00:04:58,290
an array into a new array like this

115
00:04:58,290 --> 00:05:00,870
example. New area here will be a copy of

116
00:05:00,870 --> 00:05:02,639
the rest of items array that we d

117
00:05:02,639 --> 00:05:04,850
structured above, and similarly, you can

118
00:05:04,850 --> 00:05:06,980
also spread the key value pairs of an

119
00:05:06,980 --> 00:05:09,040
object into a new object. Like this

120
00:05:09,040 --> 00:05:11,459
example. The new object here will be a

121
00:05:11,459 --> 00:05:14,310
copy of the person object. Note that these

122
00:05:14,310 --> 00:05:17,240
copies air also shallow copies. Any nested

123
00:05:17,240 --> 00:05:22,000
objects or arrays will be shared between these copies. Don't forget that.

