0
00:00:01,040 --> 00:00:02,669
[Autogenerated] The child process module

1
00:00:02,669 --> 00:00:05,280
provides four main methods that allow you

2
00:00:05,280 --> 00:00:07,509
to execute any operating system command

3
00:00:07,509 --> 00:00:10,080
from within a note process using a sub

4
00:00:10,080 --> 00:00:11,900
process, and then get the result of

5
00:00:11,900 --> 00:00:14,640
running that command in your main process.

6
00:00:14,640 --> 00:00:16,890
The sky's the limit. Here, anything you

7
00:00:16,890 --> 00:00:18,949
can do in your operating system shell can

8
00:00:18,949 --> 00:00:21,609
be done from within note. The four main

9
00:00:21,609 --> 00:00:24,629
methods are respond exact exact file, and

10
00:00:24,629 --> 00:00:27,420
Fork Fork is a special one to create some

11
00:00:27,420 --> 00:00:30,219
processes that run node itself again. This

12
00:00:30,219 --> 00:00:32,079
is the concept that powers the cluster

13
00:00:32,079 --> 00:00:34,579
concept In note. The other three can be

14
00:00:34,579 --> 00:00:37,460
used to execute regular OS commands like L

15
00:00:37,460 --> 00:00:40,740
S or P W D. For example. These have a few

16
00:00:40,740 --> 00:00:42,869
pros and cons here. But I'm gonna save you

17
00:00:42,869 --> 00:00:44,579
some research here and tell you that you

18
00:00:44,579 --> 00:00:46,649
should use this pond method. It works with

19
00:00:46,649 --> 00:00:49,840
streams, and it has very good defaults.

20
00:00:49,840 --> 00:00:51,740
Here are a few examples of things you can

21
00:00:51,740 --> 00:00:54,390
do with bond. You d structure this pond

22
00:00:54,390 --> 00:00:56,469
method out of the require call to child

23
00:00:56,469 --> 00:00:58,990
processes. Then you call this pond with a

24
00:00:58,990 --> 00:01:02,200
string representing the command pwd here,

25
00:01:02,200 --> 00:01:04,219
for example. Once you get the result of

26
00:01:04,219 --> 00:01:07,019
that, you can use the pipe method to send

27
00:01:07,019 --> 00:01:09,670
its output to the process. STD out, which

28
00:01:09,670 --> 00:01:12,370
will print the spawned process output. In

29
00:01:12,370 --> 00:01:14,129
the second example, I am reading the

30
00:01:14,129 --> 00:01:16,439
content of a vial under my home directory

31
00:01:16,439 --> 00:01:19,569
using the cat command. If you need to pass

32
00:01:19,569 --> 00:01:21,799
the command arguments, you can use the

33
00:01:21,799 --> 00:01:23,890
second argument of spawn, which is an

34
00:01:23,890 --> 00:01:25,819
array of all the arguments you wish to

35
00:01:25,819 --> 00:01:28,540
pass to the spawn process. Here's an

36
00:01:28,540 --> 00:01:30,900
example. Sending two arguments. This will

37
00:01:30,900 --> 00:01:32,370
list all the files in the current

38
00:01:32,370 --> 00:01:35,209
directory. And finally, if you need to use

39
00:01:35,209 --> 00:01:37,450
shell syntax in your spawned process, you

40
00:01:37,450 --> 00:01:39,670
can pass in a configuration object with

41
00:01:39,670 --> 00:01:42,269
shell set to true here, and with that, you

42
00:01:42,269 --> 00:01:44,359
can get all the power of the shell I am

43
00:01:44,359 --> 00:01:46,379
using, the told a here and the pipe

44
00:01:46,379 --> 00:01:48,489
operator and passing arguments to commence

45
00:01:48,489 --> 00:01:51,409
directly. This is a powerful option, but

46
00:01:51,409 --> 00:01:53,599
it's also a dangerous one, especially if

47
00:01:53,599 --> 00:01:56,189
you do not trust the source of where this

48
00:01:56,189 --> 00:01:58,840
string is coming from. So I only use this

49
00:01:58,840 --> 00:02:01,109
shell option if you need to, and if you

50
00:02:01,109 --> 00:02:05,000
have control over or trust the source of the commands

