0
00:00:01,240 --> 00:00:02,970
[Autogenerated] first up, let's talk about

1
00:00:02,970 --> 00:00:06,469
variables and block scoops. Here is one of

2
00:00:06,469 --> 00:00:10,080
my favorite JavaScript trick questions. Is

3
00:00:10,080 --> 00:00:14,240
this a valid JavaScript line of code?

4
00:00:14,240 --> 00:00:16,510
Testing it in a no trouble seems to work

5
00:00:16,510 --> 00:00:18,679
fine, which means it is valid. So the

6
00:00:18,679 --> 00:00:23,350
question is, now, what did it do? These

7
00:00:23,350 --> 00:00:27,530
are nested block scoops. UI could write

8
00:00:27,530 --> 00:00:31,339
code in here for a equal 42 and then

9
00:00:31,339 --> 00:00:34,320
access a right after and it would be

10
00:00:34,320 --> 00:00:36,280
acceptable. JavaScript does not really

11
00:00:36,280 --> 00:00:38,549
care about the spacing or new lines in

12
00:00:38,549 --> 00:00:42,920
here. A block scope is created with a pair

13
00:00:42,920 --> 00:00:45,210
of curly braces just like this example

14
00:00:45,210 --> 00:00:48,289
here. This also apply to if statements and

15
00:00:48,289 --> 00:00:50,659
four statements as well. These also get

16
00:00:50,659 --> 00:00:53,729
their own block scoops. Block scopes are a

17
00:00:53,729 --> 00:00:56,130
bit different than function scopes, which

18
00:00:56,130 --> 00:00:58,780
are created for each function. You can see

19
00:00:58,780 --> 00:01:00,759
one difference when using the var keyword

20
00:01:00,759 --> 00:01:04,040
to define variables. Variables defined

21
00:01:04,040 --> 00:01:07,030
with far inside a function scope are okay.

22
00:01:07,030 --> 00:01:10,180
They don't leak out of that scope. If you

23
00:01:10,180 --> 00:01:12,530
try to access them outside of the scope,

24
00:01:12,530 --> 00:01:15,000
you can't. As you can see here, we could

25
00:01:15,000 --> 00:01:17,329
not access the result variable that was

26
00:01:17,329 --> 00:01:21,040
defined inside the some functions scope.

27
00:01:21,040 --> 00:01:23,680
However, when we define variables with bar

28
00:01:23,680 --> 00:01:26,280
in a block scope, we-can totally access

29
00:01:26,280 --> 00:01:28,790
them outside that scope afterwards, which

30
00:01:28,790 --> 00:01:31,030
is a bit problematic. And here's one

31
00:01:31,030 --> 00:01:33,700
practical example of that. This four loop

32
00:01:33,700 --> 00:01:36,049
has an index variable that takes from 1 to

33
00:01:36,049 --> 00:01:38,980
10. You can access that variable inside

34
00:01:38,980 --> 00:01:41,530
the loop normally, but you can also access

35
00:01:41,530 --> 00:01:45,340
the same variable outside the loop. After

36
00:01:45,340 --> 00:01:48,129
all iterations air done, the value of I

37
00:01:48,129 --> 00:01:51,299
hear will be reported as 11 and that's a

38
00:01:51,299 --> 00:01:54,459
bit weird. This is why the more

39
00:01:54,459 --> 00:01:56,670
recommended way to declare variables in

40
00:01:56,670 --> 00:01:59,239
modern JavaScript is by using the let

41
00:01:59,239 --> 00:02:01,739
keyword instead of the var keyword.

42
00:02:01,739 --> 00:02:03,780
Because when defining variables with let,

43
00:02:03,780 --> 00:02:05,879
we won't have this weird out of scope

44
00:02:05,879 --> 00:02:08,310
y-access problem. If we replace this far

45
00:02:08,310 --> 00:02:11,020
here with let and do the same, test will

46
00:02:11,020 --> 00:02:14,139
try to access let after loop. We need to

47
00:02:14,139 --> 00:02:16,360
start new note session here, paste in the

48
00:02:16,360 --> 00:02:19,289
code, try to access I. After that, it will

49
00:02:19,289 --> 00:02:21,719
tell you that I is not defined, which

50
00:02:21,719 --> 00:02:24,020
makes sense because we're outside of the

51
00:02:24,020 --> 00:02:26,719
school where it was defined. So this is

52
00:02:26,719 --> 00:02:30,240
much better. Block scopes like function

53
00:02:30,240 --> 00:02:32,780
scopes can also be nested like the trick

54
00:02:32,780 --> 00:02:35,000
question that we started with this is a

55
00:02:35,000 --> 00:02:39,490
nested block scope within each level of

56
00:02:39,490 --> 00:02:41,210
nesting. The scope will protect the

57
00:02:41,210 --> 00:02:44,000
variables defined in it as long as we use

58
00:02:44,000 --> 00:02:46,659
the let keyword or the Const keyword,

59
00:02:46,659 --> 00:02:48,659
which behaves in the good way, like the

60
00:02:48,659 --> 00:02:52,409
let keyword UI use. Const. When the

61
00:02:52,409 --> 00:02:55,199
reference assigned is meant to be constant

62
00:02:55,199 --> 00:02:57,180
because references assigned with CONST

63
00:02:57,180 --> 00:02:59,719
cannot be changed, not how I'm saying

64
00:02:59,719 --> 00:03:02,150
references and not values here because

65
00:03:02,150 --> 00:03:04,639
Constant does not mean in mutability, it

66
00:03:04,639 --> 00:03:06,629
just means constant reference. But if the

67
00:03:06,629 --> 00:03:09,050
reference is foreign object, we-can still

68
00:03:09,050 --> 00:03:11,219
change this object just like we can do

69
00:03:11,219 --> 00:03:13,349
with functions that receive objects as

70
00:03:13,349 --> 00:03:16,159
arguments. So if the variable defined with

71
00:03:16,159 --> 00:03:18,090
Const. Is a scaler one like a string or

72
00:03:18,090 --> 00:03:19,849
integer, you can think of it as an

73
00:03:19,849 --> 00:03:21,960
immutable thing here. Because these scaler

74
00:03:21,960 --> 00:03:24,530
values and JavaScript are immutable. We

75
00:03:24,530 --> 00:03:27,169
can't mutate the value of a string or an

76
00:03:27,169 --> 00:03:29,300
integer in JavaScript. And because we used

77
00:03:29,300 --> 00:03:31,439
costs with these scaler values, we can't

78
00:03:31,439 --> 00:03:34,159
change the reference either. However,

79
00:03:34,159 --> 00:03:37,180
placing an array or object in a const is a

80
00:03:37,180 --> 00:03:39,960
different story. The cost will guarantee

81
00:03:39,960 --> 00:03:42,219
that the variable is pointing to the same

82
00:03:42,219 --> 00:03:44,710
ray or object, but the content of the

83
00:03:44,710 --> 00:03:47,699
array or object can still be mutated. So

84
00:03:47,699 --> 00:03:50,689
be careful here and keep that in mind to

85
00:03:50,689 --> 00:03:53,319
accomplish In mutability for objects,

86
00:03:53,319 --> 00:03:56,689
JavaScript offers a freeze method, but IT

87
00:03:56,689 --> 00:03:59,250
Onley freezes the first level of that

88
00:03:59,250 --> 00:04:01,340
object. So if you have a nested object

89
00:04:01,340 --> 00:04:03,719
within the first object, that nested

90
00:04:03,719 --> 00:04:07,169
object would not freeze. If you want to

91
00:04:07,169 --> 00:04:09,909
work with immutable object, I recommend

92
00:04:09,909 --> 00:04:13,080
the immutable JSON Library, which has an A

93
00:04:13,080 --> 00:04:15,039
P I that will guarantee objects in

94
00:04:15,039 --> 00:04:19,089
mutability. Variables defined with CONST

95
00:04:19,089 --> 00:04:21,089
are much better than those defined with

96
00:04:21,089 --> 00:04:23,759
let for scaler values and for functions,

97
00:04:23,759 --> 00:04:26,040
because you get a guarantee that the value

98
00:04:26,040 --> 00:04:28,930
did not accidentally change. Looking at

99
00:04:28,930 --> 00:04:30,930
this good example here and assuming that

100
00:04:30,930 --> 00:04:32,480
between the first and last line, there is

101
00:04:32,480 --> 00:04:35,319
a big program on the last line, we-can

102
00:04:35,319 --> 00:04:37,589
still confidently say that the answer

103
00:04:37,589 --> 00:04:40,680
variable still holds the 42 value because

104
00:04:40,680 --> 00:04:44,019
the code ran without problems while for

105
00:04:44,019 --> 00:04:46,529
the same example would let we would have

106
00:04:46,529 --> 00:04:49,029
to parse through the code to figure out if

107
00:04:49,029 --> 00:04:50,819
the answer variables still hold the 42

108
00:04:50,819 --> 00:04:53,980
values. If you need a variable toe, hold a

109
00:04:53,980 --> 00:04:56,149
changing scaler value like a counter, for

110
00:04:56,149 --> 00:04:58,879
example. Then using let is okay. But for

111
00:04:58,879 --> 00:05:04,000
the most cases, it's probably much better for you to stick with using Const.

