0
00:00:00,840 --> 00:00:02,370
[Autogenerated] note originally used the

1
00:00:02,370 --> 00:00:04,059
callback pattern for everything

2
00:00:04,059 --> 00:00:07,110
asynchronous today. Notice changing, and

3
00:00:07,110 --> 00:00:10,009
it's incrementally adopting other patterns

4
00:00:10,009 --> 00:00:12,259
as they surface in the JavaScript language

5
00:00:12,259 --> 00:00:14,609
itself. Let me show you some examples of

6
00:00:14,609 --> 00:00:18,370
that under the A sync patterns. Here there

7
00:00:18,370 --> 00:00:22,109
are six files. Let's start with one sync.

8
00:00:22,109 --> 00:00:24,429
This is the pattern usually used in other

9
00:00:24,429 --> 00:00:27,370
programming environments. Slow actions are

10
00:00:27,370 --> 00:00:29,480
usually handled with threads directly, and

11
00:00:29,480 --> 00:00:31,469
the code does not have any patterns to

12
00:00:31,469 --> 00:00:33,630
consume. Data coming from these slow

13
00:00:33,630 --> 00:00:36,640
actions. You can do that as well. In load.

14
00:00:36,640 --> 00:00:39,189
We've seen this read File sync method in

15
00:00:39,189 --> 00:00:41,090
previous videos. It's the synchronous

16
00:00:41,090 --> 00:00:43,229
version that note makes available to read

17
00:00:43,229 --> 00:00:45,350
files. You don't need any pattern to

18
00:00:45,350 --> 00:00:47,140
consume its data. You get the data when

19
00:00:47,140 --> 00:00:49,079
you call that method, and the whole

20
00:00:49,079 --> 00:00:50,969
program here does not go through the event

21
00:00:50,969 --> 00:00:53,100
loop were directly using the operating

22
00:00:53,100 --> 00:00:56,340
system synchronous file reading a P I.

23
00:00:56,340 --> 00:00:59,280
When you execute this code, you'll see the

24
00:00:59,280 --> 00:01:02,539
file data console logline before the test

25
00:01:02,539 --> 00:01:04,500
console logline because it's all

26
00:01:04,500 --> 00:01:08,299
synchronous Now. Look at the to call back

27
00:01:08,299 --> 00:01:11,620
pattern file here. This one is using the

28
00:01:11,620 --> 00:01:13,640
read file method from the built NFS

29
00:01:13,640 --> 00:01:16,290
module. This method is asynchronous. It

30
00:01:16,290 --> 00:01:18,340
needs to go through the event loop. We

31
00:01:18,340 --> 00:01:20,959
can't access the data directly after

32
00:01:20,959 --> 00:01:23,579
calling this method. This is why Note came

33
00:01:23,579 --> 00:01:26,010
up with this callback pattern, where the

34
00:01:26,010 --> 00:01:28,980
last argument of any asynchronous function

35
00:01:28,980 --> 00:01:31,849
like read file here is itself a function

36
00:01:31,849 --> 00:01:34,239
which is known as the callback function.

37
00:01:34,239 --> 00:01:36,849
This callback function is always the last

38
00:01:36,849 --> 00:01:39,640
argument of the host function. The event

39
00:01:39,640 --> 00:01:41,769
loop will make this call back executed

40
00:01:41,769 --> 00:01:44,010
when the operating system is ready with

41
00:01:44,010 --> 00:01:46,120
data for us. As I explained in the first

42
00:01:46,120 --> 00:01:48,519
module of this course, one thing I want

43
00:01:48,519 --> 00:01:50,319
you to notice about this callback pattern

44
00:01:50,319 --> 00:01:52,489
is how the callback function always

45
00:01:52,489 --> 00:01:55,099
receives an error object as it's first

46
00:01:55,099 --> 00:01:58,439
argument. The data comes after that in the

47
00:01:58,439 --> 00:02:00,090
second argument, and sometimes in many

48
00:02:00,090 --> 00:02:03,019
arguments after that. This first error

49
00:02:03,019 --> 00:02:05,959
argument is standard in the note idiomatic

50
00:02:05,959 --> 00:02:07,939
callback pattern, which is why that

51
00:02:07,939 --> 00:02:10,990
pattern is often referred to as the error

52
00:02:10,990 --> 00:02:13,520
first callback pattern. If there is an

53
00:02:13,520 --> 00:02:15,639
error in the code, this error first

54
00:02:15,639 --> 00:02:17,930
argument will be an error object, and if

55
00:02:17,930 --> 00:02:20,360
there is no error in the code, this first

56
00:02:20,360 --> 00:02:23,639
argument will be passed as null when we

57
00:02:23,639 --> 00:02:26,349
execute this file. You'll see the test

58
00:02:26,349 --> 00:02:29,729
line first and then the file data line

59
00:02:29,729 --> 00:02:33,139
here because of how read file is a sync.

60
00:02:33,139 --> 00:02:36,060
Basically, this code was executed in two

61
00:02:36,060 --> 00:02:38,550
IT orations of event Loop. The first

62
00:02:38,550 --> 00:02:41,449
iteration executed read file itself and

63
00:02:41,449 --> 00:02:44,289
the console log test lines. And that first

64
00:02:44,289 --> 00:02:46,770
iteration, Onley, defined the callback

65
00:02:46,770 --> 00:02:49,930
function. And also in that same IT oration

66
00:02:49,930 --> 00:02:52,229
note will ask the operating system for

67
00:02:52,229 --> 00:02:55,159
data later on once the operating system is

68
00:02:55,159 --> 00:02:57,550
ready with data. And this could be a few

69
00:02:57,550 --> 00:03:00,030
seconds later, the event Liu will go

70
00:03:00,030 --> 00:03:02,349
through another iteration where it will

71
00:03:02,349 --> 00:03:05,110
now invoke the callback function and

72
00:03:05,110 --> 00:03:07,300
execute the console. Log online. Four.

73
00:03:07,300 --> 00:03:10,699
Here This callback pattern is good but

74
00:03:10,699 --> 00:03:12,750
limited, and it introduces some

75
00:03:12,750 --> 00:03:15,240
complexities and inconveniences. One

76
00:03:15,240 --> 00:03:17,659
famous inconvenience about call backs is

77
00:03:17,659 --> 00:03:19,949
the fact that we need to nest them inside

78
00:03:19,949 --> 00:03:22,319
each other if we're to make a synchronous

79
00:03:22,319 --> 00:03:24,979
actions that depend on each other. Here's

80
00:03:24,979 --> 00:03:27,400
an example under three callback nesting

81
00:03:27,400 --> 00:03:29,750
that yes, we start with the same read file

82
00:03:29,750 --> 00:03:31,969
method here to read the data of a file,

83
00:03:31,969 --> 00:03:34,039
and then, once we have that data, will use

84
00:03:34,039 --> 00:03:36,530
another FS method here, right file to

85
00:03:36,530 --> 00:03:40,039
create a copy of this file. Note how I

86
00:03:40,039 --> 00:03:42,680
needed to nest, the callback of the second

87
00:03:42,680 --> 00:03:45,169
operation within the callback of the first

88
00:03:45,169 --> 00:03:47,900
operation. And if I have yet another a

89
00:03:47,900 --> 00:03:50,090
sync operation to be done after the right

90
00:03:50,090 --> 00:03:53,039
file, I'll have to do more nesting here.

91
00:03:53,039 --> 00:03:54,900
This problem is famously known as the

92
00:03:54,900 --> 00:03:56,990
Pyramid of Doom in computer programming,

93
00:03:56,990 --> 00:03:59,199
and it's not ideal. IT makes the good,

94
00:03:59,199 --> 00:04:02,039
harder to write, read and maintain.

95
00:04:02,039 --> 00:04:03,819
Luckily, since the JavaScript language

96
00:04:03,819 --> 00:04:05,909
adopted the promise pattern which we

97
00:04:05,909 --> 00:04:07,569
talked about in the modern JavaScript

98
00:04:07,569 --> 00:04:11,139
course module, Note is doing that as well.

99
00:04:11,139 --> 00:04:13,979
Look at four. Promise. If I digests no

100
00:04:13,979 --> 00:04:15,960
today comes with a tool that you can use

101
00:04:15,960 --> 00:04:18,769
to promise if I any built in asynchronous

102
00:04:18,769 --> 00:04:21,000
AP I method, and this is a very good

103
00:04:21,000 --> 00:04:23,759
start. In this example, I am using the

104
00:04:23,759 --> 00:04:26,139
promise if I function to create a new

105
00:04:26,139 --> 00:04:28,420
version of Read file, one that does not

106
00:04:28,420 --> 00:04:30,500
need a callback but rather returns a

107
00:04:30,500 --> 00:04:32,740
promise. And since it's returning a

108
00:04:32,740 --> 00:04:34,870
promise, I am able to consume this

109
00:04:34,870 --> 00:04:37,250
promise. Using the A sync await feature,

110
00:04:37,250 --> 00:04:40,029
you can promise if I any asynchronous

111
00:04:40,029 --> 00:04:42,430
action that's designed according to notes,

112
00:04:42,430 --> 00:04:44,569
idiomatic callback pattern called back

113
00:04:44,569 --> 00:04:46,589
last argument error. First argument within

114
00:04:46,589 --> 00:04:49,850
that call back. Not only that note also

115
00:04:49,850 --> 00:04:52,500
ships first level support for promises in

116
00:04:52,500 --> 00:04:55,569
some modules as well. This FS module is

117
00:04:55,569 --> 00:04:58,240
one of them. You don't really need to use

118
00:04:58,240 --> 00:05:00,389
the promise. If I function here, you can

119
00:05:00,389 --> 00:05:02,800
just use the native promises returned by

120
00:05:02,800 --> 00:05:06,110
the F S module itself. Look at the five FS

121
00:05:06,110 --> 00:05:08,370
promises that Js file and compare it with

122
00:05:08,370 --> 00:05:11,420
the four. Promise If i the Js file we're d

123
00:05:11,420 --> 00:05:13,750
structuring the read file method here from

124
00:05:13,750 --> 00:05:16,629
a special object the promises object

125
00:05:16,629 --> 00:05:19,550
that's attached to the top level a p I off

126
00:05:19,550 --> 00:05:22,490
the FS module. By doing so, you get a

127
00:05:22,490 --> 00:05:25,680
promise based read file out of the box and

128
00:05:25,680 --> 00:05:27,379
you can consume it with the A sync a week

129
00:05:27,379 --> 00:05:30,040
future as we did before. How cool is that?

130
00:05:30,040 --> 00:05:32,769
This is the near future. Off all notes AP

131
00:05:32,769 --> 00:05:35,050
ICE promises are better than callbacks.

132
00:05:35,050 --> 00:05:36,939
The code is easier to read here, and

133
00:05:36,939 --> 00:05:38,949
promises opened the door to so much

134
00:05:38,949 --> 00:05:41,569
flexibility to nest operations and even

135
00:05:41,569 --> 00:05:44,339
loop over them. Take a look at six

136
00:05:44,339 --> 00:05:46,560
promised nesting dot Js file and compare

137
00:05:46,560 --> 00:05:49,439
it with three callback nesting Dutch. Yes,

138
00:05:49,439 --> 00:05:51,889
and see how I made the exact same copy

139
00:05:51,889 --> 00:05:54,810
example, but with promises this time. And

140
00:05:54,810 --> 00:05:57,300
look how much more readable this is. UI

141
00:05:57,300 --> 00:06:00,029
just await on read file and then we await

142
00:06:00,029 --> 00:06:02,100
on right file, and if we need to await

143
00:06:02,100 --> 00:06:04,800
further, we just do it line by line. There

144
00:06:04,800 --> 00:06:07,240
is no nesting going on here, and that

145
00:06:07,240 --> 00:06:10,000
would make this code a lot easier to deal with.

