0
00:00:00,840 --> 00:00:02,169
[Autogenerated] Let's explore how to

1
00:00:02,169 --> 00:00:04,629
define and use modules in note. But before

2
00:00:04,629 --> 00:00:06,580
we do that, let me start with the basic

3
00:00:06,580 --> 00:00:10,339
question. What exactly is a module in

4
00:00:10,339 --> 00:00:13,259
note? The word module is basically a fancy

5
00:00:13,259 --> 00:00:15,810
word that means a file or a folder that

6
00:00:15,810 --> 00:00:18,989
contains code. That's IT. So this file

7
00:00:18,989 --> 00:00:21,550
here with this simple console, the log

8
00:00:21,550 --> 00:00:25,309
line is a module. I am currently under the

9
00:00:25,309 --> 00:00:27,989
four Modules folder under the one define

10
00:00:27,989 --> 00:00:30,609
use folder in the first file, right, there

11
00:00:30,609 --> 00:00:33,539
is a module. However, the reason the word

12
00:00:33,539 --> 00:00:36,600
module is a bit better to use than using

13
00:00:36,600 --> 00:00:39,659
just the terms file or folder here is

14
00:00:39,659 --> 00:00:41,719
because node actually does not just

15
00:00:41,719 --> 00:00:45,049
execute the file as is. It wraps the file

16
00:00:45,049 --> 00:00:47,590
with a function first. This is something

17
00:00:47,590 --> 00:00:49,439
that you need to remember. So let me show

18
00:00:49,439 --> 00:00:52,250
you what I mean. You know the keyword

19
00:00:52,250 --> 00:00:55,009
arguments in JavaScript? If you access

20
00:00:55,009 --> 00:00:57,369
that keyword inside the function like what

21
00:00:57,369 --> 00:01:00,030
I'm doing in this file here, the cured

22
00:01:00,030 --> 00:01:02,859
arguments will represent all the arguments

23
00:01:02,859 --> 00:01:05,700
passed into dysfunction, regardless of how

24
00:01:05,700 --> 00:01:08,310
many of them get past two IT. So if I

25
00:01:08,310 --> 00:01:11,219
execute this file to arguments under this

26
00:01:11,219 --> 00:01:13,959
folder, you'll notice How Right here This

27
00:01:13,959 --> 00:01:15,599
is the representation off the arguments,

28
00:01:15,599 --> 00:01:17,920
keyword. And it's representing all the

29
00:01:17,920 --> 00:01:20,430
arguments that we passed here to the

30
00:01:20,430 --> 00:01:23,069
dynamic arguments function. So this

31
00:01:23,069 --> 00:01:25,400
arguments cured here is a handy way to

32
00:01:25,400 --> 00:01:27,510
write functions that except a dynamic

33
00:01:27,510 --> 00:01:31,280
number of arguments. Okay, here's a weird

34
00:01:31,280 --> 00:01:32,950
question now, and this is one of the

35
00:01:32,950 --> 00:01:35,540
questions I'd ask in a note interview.

36
00:01:35,540 --> 00:01:38,430
What would know do if you console log the

37
00:01:38,430 --> 00:01:40,760
keyword arguments on the top level of a

38
00:01:40,760 --> 00:01:44,040
note file like this. If your answer is

39
00:01:44,040 --> 00:01:46,189
arguments is not defined here because we

40
00:01:46,189 --> 00:01:49,390
are not inside a function, you would not

41
00:01:49,390 --> 00:01:51,870
be getting that No job. Your answer is

42
00:01:51,870 --> 00:01:54,349
correct in a browser. But no, it has a

43
00:01:54,349 --> 00:01:57,709
different story because not internally

44
00:01:57,709 --> 00:02:00,150
wraps every file IT executes with a

45
00:02:00,150 --> 00:02:03,870
function. This console logline here will

46
00:02:03,870 --> 00:02:06,480
actually output something. Let's try IT.

47
00:02:06,480 --> 00:02:10,639
Node three. Rapper digests IT outputs

48
00:02:10,639 --> 00:02:14,030
exactly five arguments which noted, passed

49
00:02:14,030 --> 00:02:16,849
to that hidden wrapping function when it

50
00:02:16,849 --> 00:02:20,039
executes your file. You should remember

51
00:02:20,039 --> 00:02:23,150
that every time you hear the word module,

52
00:02:23,150 --> 00:02:26,219
this is not just a file. It's a function

53
00:02:26,219 --> 00:02:28,789
that receives arguments, and it will also

54
00:02:28,789 --> 00:02:32,419
return something. Let me write in comments

55
00:02:32,419 --> 00:02:34,729
here. What node does internally to this

56
00:02:34,729 --> 00:02:37,900
file? There is a function rapper here, So

57
00:02:37,900 --> 00:02:40,360
basically, there's the function call, and

58
00:02:40,360 --> 00:02:43,240
this function receives a set of arguments

59
00:02:43,240 --> 00:02:46,090
and your could becomes the body of this

60
00:02:46,090 --> 00:02:49,259
function, and then node will call this

61
00:02:49,259 --> 00:02:51,520
function. The arguments that this wrapping

62
00:02:51,520 --> 00:02:54,930
function receives are in order exports

63
00:02:54,930 --> 00:02:58,770
module require underscore, underscore file

64
00:02:58,770 --> 00:03:01,360
name and then underscore underscore dirt

65
00:03:01,360 --> 00:03:04,199
name. Have you used any of these arguments

66
00:03:04,199 --> 00:03:06,689
before? In your note file, you can use the

67
00:03:06,689 --> 00:03:09,930
exports or module the exports to define

68
00:03:09,930 --> 00:03:12,669
the A P I off the module. You can use

69
00:03:12,669 --> 00:03:15,330
require to require other modules inside

70
00:03:15,330 --> 00:03:17,439
this one and the underscore underscore

71
00:03:17,439 --> 00:03:19,830
file name has the path of this file and

72
00:03:19,830 --> 00:03:21,810
the underscore underscored Their name has

73
00:03:21,810 --> 00:03:25,139
the path to the folder hosting this file.

74
00:03:25,139 --> 00:03:27,300
All of these objects which she can use

75
00:03:27,300 --> 00:03:31,240
inside this file, are not global objects.

76
00:03:31,240 --> 00:03:33,759
They are just arguments to the wrapping

77
00:03:33,759 --> 00:03:36,090
function. They are customized for each

78
00:03:36,090 --> 00:03:39,340
file and they're different in each file.

79
00:03:39,340 --> 00:03:42,199
So when inside a file, I do something like

80
00:03:42,199 --> 00:03:47,150
exports dot a equal 42. I am just using

81
00:03:47,150 --> 00:03:48,810
one of the arguments of the wrapping

82
00:03:48,810 --> 00:03:52,199
function. The keyword exports here is not

83
00:03:52,199 --> 00:03:54,889
some globally available keyword. It's just

84
00:03:54,889 --> 00:03:57,219
the first argument to the hidden wrapping

85
00:03:57,219 --> 00:04:00,979
function. This wrapping function is also

86
00:04:00,979 --> 00:04:03,750
the reason why in node, when we define a

87
00:04:03,750 --> 00:04:06,460
variable in any file on the top level,

88
00:04:06,460 --> 00:04:10,699
like, for example, let G equal one. This G

89
00:04:10,699 --> 00:04:13,539
variable will not be a global variable at

90
00:04:13,539 --> 00:04:16,149
all. It's just a variable inside a

91
00:04:16,149 --> 00:04:19,060
function. The scope of this variable is

92
00:04:19,060 --> 00:04:22,220
the hidden wrapping function. This is

93
00:04:22,220 --> 00:04:24,810
different than what a browser would do if

94
00:04:24,810 --> 00:04:27,639
you define a variable top level like this.

95
00:04:27,639 --> 00:04:30,290
Browsers do not have this hidden wrapping

96
00:04:30,290 --> 00:04:32,319
function. So when you define a variable

97
00:04:32,319 --> 00:04:34,829
like this in a browser in a script that

98
00:04:34,829 --> 00:04:36,810
variable will be global. IT will be

99
00:04:36,810 --> 00:04:39,189
available to all the scripts you include

100
00:04:39,189 --> 00:04:41,009
after defining IT, because you're

101
00:04:41,009 --> 00:04:43,439
basically putting it on the global scope.

102
00:04:43,439 --> 00:04:46,800
But that's the browser, not note. Note has

103
00:04:46,800 --> 00:04:50,540
the wrapping function, and this G here is

104
00:04:50,540 --> 00:04:53,189
not global at all. It's just a local

105
00:04:53,189 --> 00:04:56,689
variable inside the wrapping function. It

106
00:04:56,689 --> 00:04:59,029
is really important that you remember that

107
00:04:59,029 --> 00:05:01,060
this variable here is just scoped to the

108
00:05:01,060 --> 00:05:05,540
built in wrapping function, all right. So

109
00:05:05,540 --> 00:05:08,910
besides making five arguments available to

110
00:05:08,910 --> 00:05:11,889
you inside any file The wrapping function

111
00:05:11,889 --> 00:05:15,509
also internally return something and the

112
00:05:15,509 --> 00:05:18,870
thing IT returns here is the module dot

113
00:05:18,870 --> 00:05:22,490
exports property. This is what the built

114
00:05:22,490 --> 00:05:25,500
in wrapping function return by default all

115
00:05:25,500 --> 00:05:27,720
the time. For every file it will return

116
00:05:27,720 --> 00:05:30,519
module the exports and module here is just

117
00:05:30,519 --> 00:05:32,839
the module argument that gets passed to

118
00:05:32,839 --> 00:05:34,649
the function as well. And it's the object

119
00:05:34,649 --> 00:05:37,279
that note uses to manage the dependencies

120
00:05:37,279 --> 00:05:40,480
and to manage the A _. _ _ of modules Note

121
00:05:40,480 --> 00:05:42,639
that you don't need to use the return key

122
00:05:42,639 --> 00:05:44,730
word here yourself. No, it will always

123
00:05:44,730 --> 00:05:46,930
make this function return. The module

124
00:05:46,930 --> 00:05:48,959
exports object, and this is the object we

125
00:05:48,959 --> 00:05:51,670
can use to define the A P I of this

126
00:05:51,670 --> 00:05:55,980
module. The exports object here is just an

127
00:05:55,980 --> 00:06:00,069
alias for module the exports. When node

128
00:06:00,069 --> 00:06:02,819
invokes the wrapping function, IT simply

129
00:06:02,819 --> 00:06:06,769
passes module exports here as the value of

130
00:06:06,769 --> 00:06:09,019
the first argument here. This is why we

131
00:06:09,019 --> 00:06:11,550
can use the exports keyword itself to

132
00:06:11,550 --> 00:06:13,899
export and new property on the A p I. But

133
00:06:13,899 --> 00:06:15,550
what we're really modifying when we do

134
00:06:15,550 --> 00:06:18,519
that is the module, the exports object,

135
00:06:18,519 --> 00:06:21,449
which is the one being returned. So just

136
00:06:21,449 --> 00:06:24,569
like I did exports the A equal 42. Here I

137
00:06:24,569 --> 00:06:28,290
can do module the export and let's export

138
00:06:28,290 --> 00:06:30,610
another property for this modules. AP I.

139
00:06:30,610 --> 00:06:34,160
Let's do be equal 37 I could do that

140
00:06:34,160 --> 00:06:36,430
because the module object itself is also

141
00:06:36,430 --> 00:06:38,339
an argument that gets passed to the

142
00:06:38,339 --> 00:06:42,000
wrapping function. So both A and B are

143
00:06:42,000 --> 00:06:45,649
part of the A P I of this module because

144
00:06:45,649 --> 00:06:47,810
exports is just an alias to module the

145
00:06:47,810 --> 00:06:50,269
exports and were returning module the

146
00:06:50,269 --> 00:06:53,990
exports to use this AP that we just

147
00:06:53,990 --> 00:06:55,829
defined in these two lines here. There is

148
00:06:55,829 --> 00:06:57,850
another file here in the same folder for

149
00:06:57,850 --> 00:07:01,360
require, and this is invoking the require

150
00:07:01,360 --> 00:07:03,959
function and passing it as a string the

151
00:07:03,959 --> 00:07:07,370
path of the module. The result of this

152
00:07:07,370 --> 00:07:10,120
require call is really the module the

153
00:07:10,120 --> 00:07:12,569
exports object. That node returned from

154
00:07:12,569 --> 00:07:15,350
our module. So the module AP I hear

155
00:07:15,350 --> 00:07:17,389
becomes the module that exports that the

156
00:07:17,389 --> 00:07:19,779
file returned and we can see the console

157
00:07:19,779 --> 00:07:21,519
log in here. Let's go ahead and test that

158
00:07:21,519 --> 00:07:24,680
real quick note for require. And as you

159
00:07:24,680 --> 00:07:26,569
can see here, we're getting the properties

160
00:07:26,569 --> 00:07:28,730
of the module that we defined here online.

161
00:07:28,730 --> 00:07:31,920
Seven and eight This alias relation

162
00:07:31,920 --> 00:07:34,800
between exports and module the exports is

163
00:07:34,800 --> 00:07:38,399
the reason why if we reassign the exports

164
00:07:38,399 --> 00:07:40,990
object directly. If we do exports equal

165
00:07:40,990 --> 00:07:43,339
something, we're not really changing the

166
00:07:43,339 --> 00:07:45,569
module. The experts object anymore. We're

167
00:07:45,569 --> 00:07:47,970
just reassigning the alias. We're making

168
00:07:47,970 --> 00:07:51,470
this variable point to a new local object

169
00:07:51,470 --> 00:07:54,420
in here and no longer point to module the

170
00:07:54,420 --> 00:07:58,100
exports. So if, for example, you want your

171
00:07:58,100 --> 00:08:01,500
top level A p I to-be function instead of

172
00:08:01,500 --> 00:08:03,470
an object, which is a valid case that we

173
00:08:03,470 --> 00:08:05,540
use all the time. We want our top level a

174
00:08:05,540 --> 00:08:07,660
p i to be a function not just an object.

175
00:08:07,660 --> 00:08:09,949
You can't do it this way. This is not

176
00:08:09,949 --> 00:08:12,990
okay. This will not work again because

177
00:08:12,990 --> 00:08:14,750
you're not really modifying module the

178
00:08:14,750 --> 00:08:16,740
export. You're just breaking the

179
00:08:16,740 --> 00:08:18,629
assignment reference between experts and

180
00:08:18,629 --> 00:08:20,649
module the experts. But you could totally

181
00:08:20,649 --> 00:08:24,610
do module the exports equal ah function.

182
00:08:24,610 --> 00:08:27,439
And that would be okay because module the

183
00:08:27,439 --> 00:08:29,839
export is what being returned. And I can

184
00:08:29,839 --> 00:08:31,920
change the value of module the exports

185
00:08:31,920 --> 00:08:35,549
itself. So this line here is okay. And as

186
00:08:35,549 --> 00:08:40,000
you can see, the top level a p I does not have to be an object

